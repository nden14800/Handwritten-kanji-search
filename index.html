<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手書き漢字検索</title>
    <!-- Google Fonts: Roboto -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* CSS Reset & Variables */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --font-main: 'Roboto', sans-serif;
            --bg-color: #f5f5f7;
            --text-color: #333333;
            --secondary-text: #5f6368;
            --card-bg: #ffffff;
            --canvas-bg: #ffffff;
            --border-color: #dddddd;
            --accent-color: #1a73e8;
            --accent-hover: #1557b0;
            --ink-color: #202124;
            --shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Dark Mode */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --text-color: #e8eaed;
                --secondary-text: #9aa0a6;
                --card-bg: #1e1e1e;
                --canvas-bg: #2c2c2c;
                --border-color: #444444;
                --accent-color: #8ab4f8;
                --accent-hover: #6ba5ed;
                --ink-color: #ffffff;
                --shadow: 0 4px 6px rgba(0,0,0,0.5);
            }
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
            line-height: 1.6;
        }

        h1 {
            font-weight: 700;
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .container {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Canvas Area */
        .canvas-wrapper {
            position: relative;
            width: 300px;
            height: 300px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background-color: var(--canvas-bg);
            margin-bottom: 15px;
            touch-action: none;
        }

        canvas {
            display: block;
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin-bottom: 20px;
        }

        button.control-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 24px;
            background-color: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            font-family: var(--font-main);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        button.control-btn:hover {
            background-color: var(--border-color);
        }

        button.primary {
            background-color: var(--accent-color);
            color: #ffffff;
            border: none;
        }
        
        @media (prefers-color-scheme: dark) {
             button.primary { color: #202124; }
        }

        button.primary:hover {
            background-color: var(--accent-hover);
        }

        /* Results Area */
        .results-label {
            font-size: 0.9rem;
            color: var(--secondary-text);
            margin-bottom: 8px;
            width: 100%;
            text-align: left;
            display: flex;
            justify-content: space-between;
        }
        
        .status-indicator {
            font-size: 0.8rem;
            color: var(--accent-color);
            display: none;
        }

        .results {
            width: 100%;
            min-height: 60px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-start;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .result-item {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            background-color: var(--bg-color);
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s, border-color 0.2s, background-color 0.2s;
            border: 1px solid var(--border-color);
        }

        .result-item:hover {
            transform: translateY(-2px);
            border-color: var(--accent-color);
            box-shadow: 0 2px 4px var(--shadow);
        }

        .result-item:active {
            transform: scale(0.95);
        }

        .placeholder {
            color: var(--secondary-text);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 40px;
        }
        
        .footer {
            margin-top: 20px;
            font-size: 0.8rem;
            color: var(--secondary-text);
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>手書き漢字検索</h1>

    <div class="container">
        <div class="canvas-wrapper">
            <canvas id="drawingCanvas"></canvas>
        </div>

        <div class="controls">
            <button class="control-btn" onclick="undo()">戻る</button>
            <button class="control-btn primary" onclick="clearCanvas()">クリア</button>
        </div>

        <div class="results-label">
            <span>候補 (漢字のみ)</span>
            <span id="status-indicator" class="status-indicator">認識中...</span>
        </div>
        <div class="results" id="resultsContainer">
            <div class="placeholder">ここに描画してください</div>
        </div>
    </div>

    <div class="footer">
        Powered by Google Input Tools
    </div>

    <script>
        // --- State ---
        let isDrawing = false;
        let strokes = []; // [[x[], y[]], ...]
        let currentStrokeX = [];
        let currentStrokeY = [];

        // --- Elements ---
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const resultsContainer = document.getElementById('resultsContainer');
        const statusIndicator = document.getElementById('status-indicator');

        // --- High-Resolution Canvas Setup ---
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            // Set actual size in memory (scaled)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Normalize coordinate system to CSS pixels
            ctx.scale(dpr, dpr);
            
            // Drawing Settings
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            updateInkColor();
        }

        // Initial setup and reset on resize
        setupCanvas();
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const savedStrokes = [...strokes];
                setupCanvas();
                strokes = savedStrokes;
                drawAllStrokes();
            }, 100);
        });

        // Theme Listener
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            updateInkColor();
            drawAllStrokes();
        });

        function updateInkColor() {
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink-color').trim();
        }

        // --- Canvas Events ---
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e.touches[0]); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); }, { passive: false });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); endDraw(); });

        // --- Drawing Logic (Smoothed) ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            return { 
                x: e.clientX - rect.left, 
                y: e.clientY - rect.top 
            };
        }

        function startDraw(e) {
            isDrawing = true;
            const pos = getPos(e);
            currentStrokeX = [pos.x];
            currentStrokeY = [pos.y];
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            // Dot drawing for single click
            ctx.lineTo(pos.x + 0.1, pos.y); 
            ctx.stroke();
            
            updateInkColor();
        }

        function draw(e) {
            if (!isDrawing) return;
            const pos = getPos(e);
            currentStrokeX.push(pos.x);
            currentStrokeY.push(pos.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }

        function endDraw() {
            if (!isDrawing) return;
            isDrawing = false;
            ctx.closePath();

            if (currentStrokeX.length > 0) {
                strokes.push([currentStrokeX, currentStrokeY]);
                recognizeCharacter();
            }
        }

        function stopDrawing() { if (isDrawing) endDraw(); }

        function clearCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width * dpr, rect.height * dpr);
            strokes = [];
            resultsContainer.innerHTML = '<div class="placeholder">ここに描画してください</div>';
            statusIndicator.style.display = 'none';
        }

        function undo() {
            if (strokes.length === 0) return;
            strokes.pop();
            drawAllStrokes();
            if (strokes.length > 0) {
                recognizeCharacter();
            } else {
                resultsContainer.innerHTML = '<div class="placeholder">ここに描画してください</div>';
                statusIndicator.style.display = 'none';
            }
        }

        function drawAllStrokes() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width * dpr, rect.height * dpr);
            
            updateInkColor();
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            strokes.forEach(stroke => {
                const [x, y] = stroke;
                if (x.length === 0) return;
                ctx.beginPath();
                ctx.moveTo(x[0], y[0]);
                for (let i = 1; i < x.length; i++) ctx.lineTo(x[i], y[i]);
                ctx.stroke();
            });
        }

        // --- Google API Recognition ---
        async function recognizeCharacter() {
            if (strokes.length === 0) return;
            statusIndicator.textContent = "Google 認識中...";
            statusIndicator.style.display = 'block';

            // Prepare ink data
            const inkData = strokes.map(stroke => [stroke[0], stroke[1], []]);
            
            const data = {
                app_version: 0.4, api_level: "537.36", device: window.navigator.userAgent,
                input_type: 0, options: "enable_pre_space",
                requests: [{
                    writing_guide: { 
                        writing_area_width: canvas.getBoundingClientRect().width, 
                        writing_area_height: canvas.getBoundingClientRect().height 
                    },
                    pre_context: "", max_num_results: 20, max_completions: 0, ink: inkData
                }]
            };

            try {
                const response = await fetch('https://inputtools.google.com/request?itc=ja-t-i0-handwrit&app=translate', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                if (result[0] === 'SUCCESS') {
                    const candidates = result[1][0][1];
                    // Filter for Kanji only (Unicode: 4E00-9FFF)
                    const kanjiOnly = candidates.filter(char => /^[\u4E00-\u9FFF]$/.test(char));
                    displayResults(kanjiOnly);
                }
            } catch (e) { 
                console.error(e);
                resultsContainer.innerHTML = '<div class="placeholder">エラーが発生しました</div>';
            }
            statusIndicator.style.display = 'none';
        }

        function displayResults(candidates) {
            resultsContainer.innerHTML = '';
            if (candidates.length === 0) {
                resultsContainer.innerHTML = '<div class="placeholder">候補なし</div>';
                return;
            }
            
            // Remove duplicates
            const unique = [...new Set(candidates)];
            
            unique.forEach(char => {
                const div = document.createElement('div');
                div.className = 'result-item';
                div.textContent = char;
                div.onclick = () => {
                    navigator.clipboard.writeText(char).then(() => {
                        alert(`「${char}」をコピーしました`);
                    });
                };
                resultsContainer.appendChild(div);
            });
        }
    </script>
</body>
</html>
